# Project Glossary

**Type**: glossary
**Language**: bilingual (English/Korean)
**Last Updated**: 2025-10-26
**Auto-generated**: This file is automatically generated from term definitions across the project.

---

<!-- Type: Documentation (1 terms) -->

## [[Component Definition]]

**Type**: Documentation
**Scope**: global

## 정의

Feature 문서의 Architecture 섹션에서 **컴포넌트**(주요 클래스, 모듈, 함수 그룹)를 정의하는 문법입니다.

컴포넌트는:
- 실제 코드 파일과 1:1 매핑되며
- Public 인터페이스를 노출하고
- Feature의 핵심 구현 단위입니다

## 문법 (Syntax)

Component Definition은 3가지 패턴을 지원합니다:

### Pattern 1: Numbered List (권장)

```markdown
## Architecture

### Components

1. **ComponentName** (`path/to/file.ts`)
   - publicMethod1()
   - publicMethod2()
   - publicMethod3()

2. **AnotherComponent** (`path/to/another.ts`)
   - anotherMethod()
```

**특징**:
- 가장 명확하고 간결한 형식
- 컴포넌트 이름과 파일 경로를 한 줄에 표현
- Method는 bullet point로 나열

**파싱 로직**:
```typescript
// Match: "1. **ComponentName** (`path/to/file.ts`)"
const numberedMatch = line.match(/^\s*\d+\.\s+\*\*([^*]+)\*\*\s+\(`([^`]+)`\)/);
```

### Pattern 2: Heading with File Field

```markdown
## Architecture

### ComponentName

**File**: `path/to/file.ts`

- publicMethod1()
- publicMethod2()
```

**특징**:
- 컴포넌트 이름이 ### 헤딩으로 표현
- 파일 경로는 **File**: 필드로 별도 명시
- 설명이 긴 경우 유용

**파싱 로직**:
```typescript
// Match heading: "### ComponentName"
const headingMatch = line.match(/^###\s+([A-Z][A-Za-z0-9_\s]+)/);

// Match file field: "**File**: `path`"
const fileMatch = line.match(/^\*\*File\*\*:\s*`([^`]+)`/);
```

### Pattern 3: Heading with Location Field

```markdown
## Implementation

### ComponentName

**Location**: `path/to/file.ts`

- publicMethod1()
- publicMethod2()
```

**특징**:
- Pattern 2와 유사하지만 **Location**: 사용
- **Implementation** 섹션에서도 사용 가능
- 일부 legacy 문서에서 발견됨

**파싱 로직**:
```typescript
// Match location field: "**Location**: `path`"
const fileMatch = line.match(/^\*\*Location\*\*:\s*`([^`]+)`/);
```

## Section Requirements

Component Definition은 다음 섹션 내부에서만 유효합니다:

```markdown
## Architecture      ✅ Valid
## Components        ✅ Valid
## Implementation    ✅ Valid
## Solution          ❌ Invalid
## Usage             ❌ Invalid
```

**파싱 로직**:
```typescript
// Detect valid sections
if (line.match(/^##\s+(Components|Architecture|Implementation)/i)) {
  inArchitectureSection = true;
}
```

## Method Definition

컴포넌트 아래 bullet point로 public method를 정의할 수 있습니다:

### Method Pattern 1: Function Call Style

```markdown
1. **ComponentName** (`path/to/file.ts`)
   - methodName()
   - anotherMethod()
```

**파싱 로직**:
```typescript
// Match: "- methodName()"
const methodMatch = line.match(/^\s*-\s+([A-Za-z_][A-Za-z0-9_]*)\(/);
```

### Method Pattern 2: Description Style

```markdown
1. **ComponentName** (`path/to/file.ts`)
   - methodName: Does something important
   - anotherMethod: Another feature
```

**파싱 로직**:
```typescript
// Match: "- methodName: description"
const methodMatch = line.match(/^\s*-\s+([A-Za-z_][A-Za-z0-9_]*):/);
```

## Parser Implementation

**File**: src/tools/implementation-coverage.ts:165-280

**Function**: `extractDocumentedComponents()`

**Interface**:
```typescript
export interface DocumentedComponent {
  name: string;           // Component name
  filePath: string;       // Relative path to source file
  description: string;    // Optional description
  featureId: string;      // Parent feature ID
  docLine: number;        // Line number in doc
  publicMethods: string[]; // List of public methods
}

export function extractDocumentedComponents(
  docContent: string,
  featureId: string
): DocumentedComponent[];
```

**Algorithm**:
1. Find Architecture/Components/Implementation section
2. Parse numbered list pattern OR heading pattern
3. Extract file path from inline OR **File**/**Location** field
4. Collect public methods from bullet points
5. Save component when next component starts or section ends

## Validation Rules

### Rule 1: Component Name Format

컴포넌트 이름은 대문자로 시작해야 합니다:

```markdown
✅ Valid:
1. **ComponentName** (`path.ts`)
1. **Component Name** (`path.ts`)  # Spaces allowed

❌ Invalid:
1. **componentName** (`path.ts`)   # Lowercase start
1. **component_name** (`path.ts`)  # Lowercase start
```

### Rule 2: File Path Required

모든 컴포넌트는 파일 경로를 명시해야 합니다:

```markdown
✅ Valid:
1. **ComponentName** (`path/to/file.ts`)

❌ Invalid:
1. **ComponentName**  # Missing file path
```

### Rule 3: File Must Exist

명시된 파일 경로는 실제로 존재해야 합니다:

```markdown
✅ Valid:
1. **TermParser** (`src/parsers/TermParser.ts`)  # File exists

❌ Invalid:
1. **MissingComponent** (`src/missing.ts`)  # File not found
```

### Rule 4: Valid Section

컴포넌트는 올바른 섹션 내부에 정의되어야 합니다:

```markdown
✅ Valid:
## Architecture
### Components
1. **ComponentName** (`path.ts`)

✅ Valid:
## Implementation
### ComponentName
**File**: `path.ts`

❌ Invalid:
## Solution
1. **ComponentName** (`path.ts`)  # Wrong section
```

## Examples

### ✅ Valid Example 1: Numbered List

**Feature**: 13_ValidateTerms
**Location**: tasks/features/13_ValidateTerms.md:56-75

```markdown
## Architecture

### Components

1. **TermParser** (`src/parsers/TermParser.ts`)
   - extractDefinitions()
   - extractReferences()

2. **TermRegistry** (`src/tools/term-registry.ts`)
   - addDefinition()
   - find()
   - search()
   - validate()

3. **validateTerms** (`src/tools/validate-terms.ts`)
   - validateTerms()

4. **Term Commands** (`src/tools/term-commands.ts`)
   - listTerms()
   - findTerm()
```

### ✅ Valid Example 2: Heading with File

**Feature**: 10_Internationalization
**Location**: tasks/features/10_Internationalization.md:40-55

```markdown
## Architecture

### TranslationManager

**File**: `src/shared/i18n.ts`

- loadTranslations()
- t()
- setLocale()
```

### ✅ Valid Example 3: Heading with Location

**Feature**: 09_MultiLanguageParser
**Location**: tasks/features/09_MultiLanguageParser.md:45-65

```markdown
## Implementation

### ParserFactory

**Location**: `src/parsers/ParserFactory.ts`

- getParser()
- registerParser()
```

### ❌ Invalid Example 1: Missing Path

See: docs/syntax/examples/component-missing-path.md

```markdown
## Architecture

### Components

1. **ComponentName**
   - method1()
```

**Error**: Component missing file path

### ❌ Invalid Example 2: Wrong Section

See: docs/syntax/examples/component-wrong-section.md

```markdown
## Solution

1. **ComponentName** (`path.ts`)
```

**Error**: Component defined outside Architecture/Components/Implementation section

## Related Terms

- [[Architecture Section]] - 상위 섹션 정의
- [[Public Interface]] - 구현된 코드 인터페이스
- [[Implementation Coverage]] - 이 문법을 사용하는 기능
- [[Frontmatter Field]] - code_references와 연계

## Usage Commands

Check component definitions:

```bash

**Source**: tasks/syntax/Component-Definition.md:20

---

<!-- Type: Test (1 terms) -->

## [[Test Reference]]

**Type**: Test
**Scope**: global

## 정의

Feature 문서에서 **테스트 파일**을 참조하는 문법입니다.

테스트 참조는:
- 실제 테스트 파일과 1:1 매핑되며
- 어떤 컴포넌트를 테스트하는지 명시하고
- 테스트 커버리지 분석에 사용됩니다

## 문법 (Syntax)

Test Reference는 2가지 패턴을 지원합니다:

### Pattern 1: JSDoc-style Reference (권장)

```markdown
## Testing

/**
 * @test path/to/test-file.test.ts
 */
```

**특징**:
- JSDoc 스타일로 명확하게 표현
- @test 태그로 테스트 파일 지정
- 간결하고 파싱하기 쉬움

**파싱 로직**:
```typescript
// Match: "* @test path/to/test.ts"
const testMatch = line.match(/\*\s+@test\s+(.+)/);
```

### Pattern 2: Inline Code Reference

```markdown
## Testing

Tests: `path/to/test-file.test.ts`
```

**특징**:
- 인라인 스타일로 간단하게 표현
- Tests: 접두사 사용
- Legacy 문서에서 발견됨

**파싱 로직**:
```typescript
// Match: "Tests: `path/to/test.ts`"
const testMatch = line.match(/Tests:\s*`([^`]+)`/);
```

## Section Requirements

Test Reference는 다음 섹션 내부에서만 유효합니다:

```markdown
## Testing          ✅ Valid
## Tests            ✅ Valid
## Test Coverage    ✅ Valid
## Solution         ❌ Invalid
## Architecture     ❌ Invalid
```

**파싱 로직**:
```typescript
// Detect valid sections
if (line.match(/^##\s+(Testing|Tests|Test Coverage)/i)) {
  inTestSection = true;
}
```

## Parser Implementation

**File**: src/tools/implementation-coverage.ts

**Function**: `extractTestReferences()`

**Interface**:
```typescript
export interface TestReference {
  testPath: string;      // Relative path to test file
  featureId: string;     // Parent feature ID
  docLine: number;       // Line number in doc
  testedComponents?: string[]; // Components being tested
}

export function extractTestReferences(
  docContent: string,
  featureId: string
): TestReference[];
```

**Algorithm**:
1. Find Testing/Tests section
2. Parse JSDoc @test pattern OR inline Tests: pattern
3. Extract test file path
4. Validate file exists
5. Return test references

## Validation Rules

### Rule 1: Test File Path Required

테스트 참조는 파일 경로를 명시해야 합니다:

```markdown
✅ Valid:
/**
 * @test src/tests/feature.test.ts
 */

❌ Invalid:
/**
 * @test
 */
```

### Rule 2: Test File Must Exist

명시된 테스트 파일은 실제로 존재해야 합니다:

```markdown
✅ Valid:
/**
 * @test src/tests/term-parser.test.ts
 */  # File exists

❌ Invalid:
/**
 * @test src/tests/missing.test.ts
 */  # File not found
```

### Rule 3: Valid Section

테스트 참조는 올바른 섹션 내부에 정의되어야 합니다:

```markdown
✅ Valid:
## Testing
/**
 * @test src/tests/feature.test.ts
 */

❌ Invalid:
## Solution
/**
 * @test src/tests/feature.test.ts
 */  # Wrong section
```

### Rule 4: Test File Naming Convention

테스트 파일은 `.test.ts` 또는 `.spec.ts` 확장자를 가져야 합니다:

```markdown
✅ Valid:
/**
 * @test src/tests/feature.test.ts
 */
/**
 * @test src/tests/feature.spec.ts
 */

❌ Invalid:
/**
 * @test src/tests/feature.ts
 */  # Missing .test or .spec
```

## Examples

### ✅ Valid Example 1: JSDoc Style

**Feature**: 13_ValidateTerms
**Location**: tasks/features/13_ValidateTerms.md:85

```markdown
## Testing

/**
 * @test src/tests/term-parser.test.ts
 * @test src/tests/term-registry.test.ts
 * @test src/tests/validate-terms.test.ts
 */
```

### ✅ Valid Example 2: Inline Style

**Feature**: 09_MultiLanguageParser
**Location**: tasks/features/09_MultiLanguageParser.md:75

```markdown
## Tests

Tests: `src/tests/parser-factory.test.ts`
Tests: `src/tests/language-detection.test.ts`
```

### ❌ Invalid Example 1: Missing Path

See: docs/syntax/examples/test-missing-path.md

```markdown
## Testing

/**
 * @test
 */
```

**Error**: Test reference missing file path

### ❌ Invalid Example 2: Wrong Format

See: docs/syntax/examples/test-wrong-format.md

```markdown
## Testing

Test: feature.test.ts
```

**Error**: Invalid test reference format (missing backticks or @test tag)

## Related Terms

- [[Component Definition]] - 테스트 대상 컴포넌트
- [[Implementation Coverage]] - 이 문법을 사용하는 기능
- [[Frontmatter Field]] - test_files와 연계
- [[Test Doc Lookup]] - 테스트 문서 조회 기능

## Usage Commands

Check test references:

```bash

**Source**: tasks/syntax/Test-Reference.md:19

---

<!-- Type: Content (1 terms) -->

## [[Term Definition]]

**Type**: Content
**Scope**: global

## 정의

문서에서 용어를 정의하는 문법입니다. 정의된 용어는 `[[Term]]` 형식으로 다른 문서에서 참조할 수 있습니다.

## 문법 (Syntax)

### 기본 형식

```markdown

**Source**: tasks/syntax/Term-Definition.md:19

---

<!-- Type: Code (1 terms) -->

## [[Public Interface]]

**Type**: Code
**Scope**: global

## 정의

Feature 문서에서 **Public Interface**(공개 API, 노출된 함수/메서드)를 정의하는 문법입니다.

Public Interface는:
- 컴포넌트가 외부에 노출하는 공개 API를 명시하고
- 실제 코드 구현과 비교하여 커버리지를 확인하며
- 문서와 코드의 동기화를 보장합니다

## 문법 (Syntax)

Public Interface는 2가지 패턴을 지원합니다:

### Pattern 1: Bullet List under Component (권장)

```markdown
## Architecture

### Components

1. **ComponentName** (`path/to/file.ts`)
   - publicMethod1()
   - publicMethod2()
   - publicMethod3()
```

**특징**:
- 컴포넌트 정의 아래 직접 나열
- 함수 호출 형식으로 표현
- 가장 일반적인 형식

**파싱 로직**:
```typescript
// Match: "- methodName()"
const methodMatch = line.match(/^\s*-\s+([A-Za-z_][A-Za-z0-9_]*)\(/);
```

### Pattern 2: Public Interface Section

```markdown
## Public Interface

### ComponentName

- methodName()
- anotherMethod()
- thirdMethod()
```

**특징**:
- 별도 Public Interface 섹션에서 정의
- 컴포넌트별로 그룹화
- 인터페이스가 복잡한 경우 유용

**파싱 로직**:
```typescript
// Detect section
if (line.match(/^##\s+Public Interface/i)) {
  inInterfaceSection = true;
}

// Match component heading
const componentMatch = line.match(/^###\s+([A-Z][A-Za-z0-9_\s]+)/);

// Match methods
const methodMatch = line.match(/^\s*-\s+([A-Za-z_][A-Za-z0-9_]*)\(/);
```

## Method Syntax Variants

메서드는 여러 형식으로 표현할 수 있습니다:

### Variant 1: Function Call Style

```markdown
- methodName()
- anotherMethod()
```

### Variant 2: With Description

```markdown
- methodName(): Returns something important
- anotherMethod(): Does something else
```

### Variant 3: With Parameters

```markdown
- methodName(param1, param2)
- anotherMethod(options?: Options)
```

**파싱 로직**:
```typescript
// All variants match:
const methodMatch = line.match(/^\s*-\s+([A-Za-z_][A-Za-z0-9_]*)\s*\(/);
// Extract just the method name (everything before '(')
```

## Section Requirements

Public Interface는 다음 섹션에서 정의할 수 있습니다:

```markdown
## Architecture        ✅ Valid (under Components)
## Components          ✅ Valid (under numbered list)
## Implementation      ✅ Valid (under Components)
## Public Interface    ✅ Valid (dedicated section)
## Solution            ❌ Invalid
## Usage               ❌ Invalid
```

## Parser Implementation

**File**: src/tools/implementation-coverage.ts

**Function**: `extractPublicInterfaces()`

**Interface**:
```typescript
export interface PublicInterface {
  componentName: string;    // Parent component name
  methodName: string;       // Method name
  signature?: string;       // Full signature with params
  description?: string;     // Optional description
  featureId: string;        // Parent feature ID
  docLine: number;          // Line number in doc
}

export function extractPublicInterfaces(
  docContent: string,
  featureId: string
): PublicInterface[];
```

**Algorithm**:
1. Find Architecture/Components/Public Interface section
2. Identify parent component
3. Parse bullet list of methods
4. Extract method name, signature, description
5. Link to parent component
6. Return all public interfaces

## Validation Rules

### Rule 1: Method Name Format

메서드 이름은 유효한 JavaScript 식별자여야 합니다:

```markdown
✅ Valid:
- methodName()
- _privateMethod()
- method123()

❌ Invalid:
- 123method()      # Starts with number
- method-name()    # Contains hyphen
- method name()    # Contains space
```

### Rule 2: Parentheses Required

모든 메서드는 괄호를 포함해야 합니다:

```markdown
✅ Valid:
- methodName()
- methodName(param)

❌ Invalid:
- methodName      # Missing parentheses
```

### Rule 3: Must Have Parent Component

Public Interface는 컴포넌트 아래에 정의되어야 합니다:

```markdown
✅ Valid:
1. **ComponentName** (`path.ts`)
   - methodName()

✅ Valid:
## Public Interface
### ComponentName
- methodName()

❌ Invalid:
## Public Interface
- methodName()    # No parent component
```

### Rule 4: Valid Section

Public Interface는 올바른 섹션에서만 정의할 수 있습니다:

```markdown
✅ Valid:
## Architecture
1. **ComponentName** (`path.ts`)
   - methodName()

✅ Valid:
## Public Interface
### ComponentName
- methodName()

❌ Invalid:
## Usage
### ComponentName
- methodName()    # Wrong section
```

## Examples

### ✅ Valid Example 1: Under Component

**Feature**: 13_ValidateTerms
**Location**: tasks/features/13_ValidateTerms.md:78-82

```markdown
## Architecture

### Components

1. **TermRegistry** (`src/tools/term-registry.ts`)
   - addDefinition()
   - find()
   - search()
   - validate()
```

### ✅ Valid Example 2: Dedicated Section

**Feature**: 09_MultiLanguageParser
**Location**: tasks/features/09_MultiLanguageParser.md:55-60

```markdown
## Public Interface

### ParserFactory

- getParser(language: string)
- registerParser(language: string, parser: Parser)
- getSupportedLanguages()
```

### ✅ Valid Example 3: With Descriptions

```markdown
## Public Interface

### TermParser

- extractDefinitions(): Extract term definitions from markdown
- extractReferences(): Find all term references
- validate(): Validate term usage
```

### ❌ Invalid Example 1: Missing Methods

See: docs/syntax/examples/interface-missing-methods.md

```markdown
## Architecture

1. **ComponentName** (`path.ts`)
```

**Warning**: Component has no public methods defined

### ❌ Invalid Example 2: Wrong Section

See: docs/syntax/examples/interface-wrong-section.md

```markdown
## Solution

### ComponentName

- methodName()
```

**Error**: Public Interface defined in invalid section

## Related Terms

- [[Component Definition]] - 인터페이스를 가진 컴포넌트
- [[Entry Point]] - 진입점 함수/메서드
- [[Implementation Coverage]] - 이 문법을 사용하는 기능
- [[Frontmatter Field]] - entry_point와 연계

## Usage Commands

Check public interfaces:

```bash

**Source**: tasks/syntax/Public-Interface.md:19

---

<!-- Type: Metadata (1 terms) -->

## [[Frontmatter Field]]

**Type**: Metadata
**Scope**: global

## 정의

문서 최상단의 YAML 형식 메타데이터 필드입니다. Feature, interface, shared type 등 모든 문서 타입에서 사용됩니다.

## 문법 (Syntax)

### 기본 구조

```yaml
---
field_name: "value"
---
```

## Required Fields by Document Type

### Feature Documents

```yaml
---
feature: "13_ValidateTerms"          # Required: Feature ID
entry_point: "src/cli.ts"            # Optional: Entry point file/line
type: "validation"                   # Optional: Feature type
status: "implemented"                # Optional: Implementation status
code_references:                     # Optional: Source files
  - "src/tools/validate-terms.ts"
  - "src/parsers/TermParser.ts"
test_files:                          # Optional: Test files
  - "tests/unit/term-validation.test.ts"
related_features:                    # Optional: Related feature IDs
  - "06_ValidateAll"
  - "10_Internationalization"
---
```

### Syntax Documents

```yaml
---
feature: "syntax:Component-Definition"  # Required: syntax: prefix
type: "syntax"                          # Required: Must be "syntax"
status: "documented"                    # Required
parser: "src/tools/file.ts:function"    # Required: Parser location
validator: "src/validators/file.ts"     # Optional: Validator location
related_features:                       # Optional
  - "18_ImplementationCoverage"
examples:                               # Optional
  valid:
    - "path/to/example.md:10-20"
  invalid:
    - "path/to/invalid-example.md"
---
```

### Interface Documents

```yaml
---
from: "00_Init"                      # Required: Source feature
to: "01_ValidateMigration"           # Required: Target feature
type: "command"                      # Optional: Interface type
status: "implemented"                # Optional
shared_types:                        # Optional
  - "00--01_ValidationResult"
---
```

### Shared Type Documents

```yaml
---
interfaces:                          # Required: Interface IDs
  - "00--01"
  - "00--02"
type: "shared"                       # Required: Must be "shared"
status: "implemented"                # Optional
---
```

## Field Definitions

### feature

**Required**: Yes (for feature and syntax documents)
**Format**: `<number>_<CamelCase>` or `syntax:<Name>`

```yaml
✅ Valid:
feature: "13_ValidateTerms"
feature: "syntax:Component-Definition"

❌ Invalid:
feature: "validate-terms"           # Wrong format
feature: "13-validate-terms"        # Wrong format
```

### entry_point

**Required**: No
**Format**: `<file>` or `<file>:<line>` or `<file>:<start>-<end>`

```yaml
✅ Valid:
entry_point: "src/cli.ts"
entry_point: "src/cli.ts:72-86"
entry_point: "src/tools/entry-point-detector.ts"

❌ Invalid:
entry_point: "cli.ts"                # Missing src/
```

### type

**Required**: No (Yes for syntax and shared documents)
**Values**: `validation`, `feature`, `tool`, `documentation`, `syntax`, `shared`, etc.

```yaml
✅ Valid:
type: "validation"
type: "syntax"
type: "shared"

❌ Invalid:
type: "invalid-type"                # Unknown type
```

### status

**Required**: No
**Values**: `planned`, `active`, `implemented`, `documented`, `deprecated`

```yaml
✅ Valid:
status: "implemented"
status: "active"
status: "documented"

❌ Invalid:
status: "done"                      # Use "implemented"
status: "in-progress"               # Use "active"
```

### code_references

**Required**: No
**Format**: Array of relative file paths

```yaml
✅ Valid:
code_references:
  - "src/tools/validate-terms.ts"
  - "src/parsers/TermParser.ts"

❌ Invalid:
code_references:
  - "/absolute/path/file.ts"       # Absolute paths not allowed
  - "file.ts"                      # Missing directory
```

### test_files

**Required**: No
**Format**: Array of relative test file paths

```yaml
✅ Valid:
test_files:
  - "tests/unit/term-validation.test.ts"
  - "tests/integration/term-commands.test.ts"

❌ Invalid:
test_files:
  - "term-validation.test.ts"      # Missing tests/ directory
```

### related_features

**Required**: No
**Format**: Array of feature IDs

```yaml
✅ Valid:
related_features:
  - "06_ValidateAll"
  - "10_Internationalization"
  - "syntax:Component-Definition"

❌ Invalid:
related_features:
  - "validate-all"                 # Wrong format
```

### parser

**Required**: Yes (for syntax documents)
**Format**: `<file>:<function>` or `<file>:<line>`

```yaml
✅ Valid:
parser: "src/tools/implementation-coverage.ts:extractDocumentedComponents"
parser: "src/tools/structure.ts:165-280"

❌ Invalid:
parser: "extractDocumentedComponents"  # Missing file
parser: "src/tools/file.ts"           # Missing function/line
```

### validator

**Required**: No
**Format**: `<file>` or `<file>:<function>`

```yaml
✅ Valid:
validator: "src/validators/component-validator.ts"
validator: "src/validators/syntax-validator.ts:validateComponent"

❌ Invalid:
validator: "component-validator"   # Missing path
```

### examples

**Required**: No (Recommended for syntax documents)
**Structure**: `{ valid: string[], invalid: string[] }`

```yaml
✅ Valid:
examples:
  valid:
    - "tasks/features/13_ValidateTerms.md:56-75"
  invalid:
    - "docs/syntax/examples/component-missing-path.md"

❌ Invalid:
examples:
  - "example.md"                   # Wrong structure, needs valid/invalid keys
```

## Parser Implementation

**File**: src/tools/structure.ts

**Function**: `validateStructure()`

Validates frontmatter structure and required fields for each document type.

## Validation Rules

### Rule 1: Valid YAML Syntax

Frontmatter must be valid YAML:

```yaml
✅ Valid:
---
feature: "13_ValidateTerms"
type: "validation"
---

❌ Invalid:
---
feature: 13_ValidateTerms    # Missing quotes for values with underscores
type: validation:            # Extra colon
---
```

### Rule 2: Required Fields Present

Each document type must have its required fields:

```yaml
✅ Valid (Feature):
---
feature: "13_ValidateTerms"
---

❌ Invalid (Feature):
---
type: "validation"           # Missing required 'feature' field
---
```

### Rule 3: Field Types Correct

Field values must match expected types:

```yaml
✅ Valid:
code_references:
  - "src/file1.ts"
  - "src/file2.ts"

❌ Invalid:
code_references: "src/file.ts"  # Should be array, not string
```

### Rule 4: Field Values Valid

Field values must be from allowed sets:

```yaml
✅ Valid:
status: "implemented"

❌ Invalid:
status: "done"              # Not an allowed status value
```

### Rule 5: File Paths Exist

Referenced files should exist:

```yaml
✅ Valid:
code_references:
  - "src/tools/validate-terms.ts"  # File exists

❌ Invalid:
code_references:
  - "src/tools/nonexistent.ts"     # File not found
```

## Examples

### ✅ Valid Example 1: Feature Document

**Location**: tasks/features/13_ValidateTerms.md:1-14

```yaml
---
feature: "13_ValidateTerms"
entry_point: "src/cli.ts"
type: "validation"
status: "implemented"
code_references:
  - "src/tools/validate-terms.ts"
  - "src/tools/term-registry.ts"
  - "src/parsers/TermParser.ts"
test_files:
  - "tests/unit/term-validation.test.ts"
related_features:
  - "06_ValidateAll"
  - "10_Internationalization"
---
```

### ✅ Valid Example 2: Syntax Document

**Location**: tasks/syntax/Component-Definition.md:1-14

```yaml
---
feature: "syntax:Component-Definition"
type: "syntax"
status: "documented"
parser: "src/tools/implementation-coverage.ts:extractDocumentedComponents"
validator: "src/validators/component-validator.ts"
related_features:
  - "18_ImplementationCoverage"
examples:
  valid:
    - "tasks/features/13_ValidateTerms.md:56-75"
  invalid:
    - "docs/syntax/examples/component-missing-path.md"
---
```

### ❌ Invalid Example 1: Missing Required Field

See: docs/syntax/examples/frontmatter-missing-required.md

```yaml
---
type: "validation"
status: "implemented"
---
```

**Error**: Missing required field `feature`

### ❌ Invalid Example 2: Invalid Type Value

See: docs/syntax/examples/frontmatter-invalid-type.md

```yaml
---
feature: "13_ValidateTerms"
type: "invalid-type"
---
```

**Error**: Invalid type value. Allowed: validation, feature, tool, documentation, syntax, shared

## Related Terms

- [[Term Definition]] - Terms also use frontmatter
- [[Test Reference]] - test_files field
- [[Component Definition]] - code_references field

## Usage Commands

Validate frontmatter:

```bash

**Source**: tasks/syntax/Frontmatter-Field.md:19

---

<!-- Type: Concept (6 terms) -->

## [[Documentation Symbol]]

**Type**: concept
**Scope**: global
**Aliases**: 문서 심볼
**Related**: [[Term Definition]], [[Code Interface]]

문서에서 정의된 용어를 코드의 심볼처럼 취급하는 개념을 의미한다.

**특징**:
- 명시적 정의 필요 (`## [[Term]]`)
- 고유 식별자 (term name)
- 타입 정보 (concept, entity, process)
- 스코프 (global, document)
- 참조 추적 가능 (`[[Term]]`)

**vs Code Symbol**:
- Code Symbol: `export class Foo { }` (컴파일러가 강제)
- Documentation Symbol: `## [[Foo]]` (검증 도구가 강제)

**목적**:
- 문서 간 용어 충돌 방지
- 용어 일관성 보장
- 정의되지 않은 용어 사용 방지

**Source**: docs/terms/documentation-symbol.md:1

---

## [[Entry Point Module]]

**Type**: concept
**Scope**: global
**Aliases**: 진입점 모듈, entry point
**Related**: [[Top-Level Interface]], [[Public API]]

외부 사용자가 접근할 수 있는 최상위 public API 모듈을 의미한다.

**특징**:
- CLI entry point, library export, API endpoint 등의 역할을 수행
- package.json의 main, bin, exports 필드에 명시
- 문서의 `entry_point` frontmatter로 표시

**타입**:
- `cli`: 커맨드라인 인터페이스 진입점
- `library`: 라이브러리 public export
- `api`: API 모듈 진입점

**예시**:
- `src/cli.ts` - CLI 진입점
- `src/parsers/ParserFactory.ts` - Parser 시스템 API
- `src/shared/i18n.ts` - Internationalization API

**Source**: docs/terms/entry-point-module.md:1

---

## [[Public API]]

**Type**: concept
**Scope**: global
**Aliases**: 공개 API
**Related**: [[Entry Point Module]], [[Top-Level Interface]]

외부 사용자가 사용할 수 있도록 의도적으로 노출된 모든 인터페이스, 함수, 클래스의 집합을 의미한다.

**구성 요소**:
- [[Entry Point Module]]에서 export된 [[Top-Level Interface]]
- 문서화되고 안정적인 API
- Breaking change 시 버전 관리 대상

**제외 대상**:
- `@internal`로 표시된 구현 세부사항
- 테스트 전용 유틸리티
- 문서화되지 않은 experimental API

**Source**: docs/terms/public-api.md:1

---

## [[Spec Orphan]]

**Type**: concept
**Scope**: global
**Aliases**: 스펙 고아, 명세 고아
**Parent**: [[Orphan Detection]]

문서화되지 않은 public export (interface, class, function)를 의미한다.

**정의 조건**:
- 파일이 문서화됨 (code_references에 포함)
- 그러나 특정 export는 문서에 언급되지 않음
- Public API이지만 명세 누락

**예시**:
```typescript
// src/utils/config.ts (문서화됨)
export function loadConfig() { }      // ✅ 문서화됨
export function validateConfig() { }  // ❌ Spec Orphan (언급 없음)
```

**검증 방법**:
1. 문서화된 파일에서 모든 export 추출
2. 각 export가 문서에 언급되었는지 확인
3. 언급되지 않은 export를 Spec Orphan으로 보고

**관련 명령어**:
```bash
edgedoc validate spec-orphans
```

**Source**: docs/terms/spec-orphan.md:1

---

## [[Top-Level Interface]]

**Type**: concept
**Scope**: global
**Aliases**: 최상위 인터페이스
**Parent**: [[Code Interface]]
**Related**: [[Entry Point Module]], [[Public API]]

[[Entry Point Module]]에서 직접 export되어 외부 사용자가 접근 가능한 [[Code Interface]]를 의미한다.

**정의 조건**:
- Entry point module에서 `export` 키워드로 노출
- 외부에서 `import`하여 사용 가능
- Public API의 일부를 구성

**예시**:
```typescript
// src/parsers/ParserFactory.ts (Entry Point Module)
export class ParserFactory { }        // ✅ Top-Level Interface
export interface ILanguageParser { }  // ✅ Top-Level Interface

class InternalHelper { }              // ❌ Not exported
```

**제외 대상**:
- `export` 없이 선언된 내부 클래스/인터페이스
- `@internal` JSDoc으로 표시된 내부 API
- Private 또는 protected 멤버

**Source**: docs/terms/top-level-interface.md:1

---

## [[Type Definition]]

**Type**: concept
**Scope**: global
**Aliases**: 타입 정의
**Related**: [[Code Interface]]
**Not to Confuse**: [[Term Definition]]

코드에서 TypeScript 타입을 정의하는 것을 의미한다.

**예시**:
```typescript
// Type Definition
type ParseResult = {
  imports: ImportInfo[];
  exports: ExportInfo[];
};

interface ILanguageParser {
  parse(code: string): ParseResult;
}
```

**vs [[Term Definition]]**:
- Type Definition: 코드의 타입 정의
- Term Definition: 문서의 용어 정의

**Source**: docs/terms/type-definition.md:1

---

<!-- Type: Entity (9 terms) -->

## [[Code Interface]]

**Type**: entity
**Scope**: global
**Aliases**: 코드 인터페이스
**Related**: [[Top-Level Interface]], [[Type Definition]]
**Not to Confuse**: [[User Interface]]

TypeScript의 interface, class, type 등 코드 수준에서 정의된 인터페이스를 의미한다.

**예시**:
```typescript
export interface ILanguageParser { }  // Code Interface
export class ParserFactory { }        // Code Interface
export type ParseResult = { }         // Code Interface
```

**포함 범위**:
- TypeScript interface 선언
- 클래스 (class) 선언
- 타입 별칭 (type alias)
- 함수 시그니처

**Source**: docs/terms/code-interface.md:1

---

## [[Export Analyzer]]

**Type**: entity
**Scope**: global
**Aliases**: 익스포트 분석기
**Related**: [[Code Interface]], [[Top-Level Interface]]

코드 파일에서 export된 [[Code Interface]]를 추출하고 분석하는 컴포넌트를 의미한다.

**주요 기능**:
- 파일에서 모든 exported interface, class, function, type 추출
- Method 및 property 정보 추출 (class의 경우)
- JSDoc 주석 파싱
- `@internal`, `@deprecated` 마커 인식

**입력**: 소스 코드 파일 경로
**출력**: `InterfaceDefinition[]` (interface 정의 배열)

**구현 위치** (예정): `src/analyzers/ExportAnalyzer.ts`

**Source**: docs/terms/export-analyzer.md:1

---

## [[Frontmatter]]

**Type**: entity
**Scope**: global
**Aliases**: 프론트매터
**Related**: [[Code References]], [[Entry Point Module]]

마크다운 파일 상단의 YAML 메타데이터 블록을 의미한다.

**형식**:
```yaml
---
type: feature
status: active
entry_point: "src/cli.ts"
code_references:
  - "src/tools/init.ts"
---
```

**주요 필드**:
- `type`: 문서 타입 (feature, design, guide 등)
- `status`: 상태 (active, deprecated 등)
- `entry_point`: [[Entry Point Module]] 경로
- `code_references`: [[Code References]] 목록
- `related_features`: 관련 기능 문서
- `public_interfaces`: [[Top-Level Interface]] 목록 (향후)

**용도**:
- 문서 메타데이터 관리
- 검증 도구의 입력 데이터
- 문서 간 관계 추적

**Source**: docs/terms/frontmatter.md:1

---

## [[Interface Graph]]

**Type**: entity
**Scope**: global
**Aliases**: 인터페이스 그래프
**Related**: [[Code Interface]], [[Top-Level Interface]], [[Export Analyzer]]

[[Code Interface]] 간의 사용 관계를 추적하는 그래프 자료구조를 의미한다. [[Export Analyzer]]로 추출한 인터페이스 정보를 기반으로 구성된다.

**구성 요소**:
- **Nodes**: 각 [[Code Interface]]
- **Edges**: interface 간 사용 관계 (imports, extends, implements)
- **Metadata**: 각 interface의 사용 횟수, 문서화 여부

**주요 기능**:
- Interface 의존성 추적
- Orphan interface 탐지 (사용되지 않는 interface)
- Transitive dependency 분석
- 순환 의존성 감지

**구현 위치** (예정): `src/analyzers/InterfaceGraph.ts`

**Source**: docs/terms/interface-graph.md:1

---

## [[Language Parser]]

**Type**: entity
**Scope**: global
**Aliases**: 언어 파서, ILanguageParser
**Related**: [[Parser Factory]], [[Parse Result]]

특정 프로그래밍 언어의 소스 코드를 파싱하는 인터페이스를 의미한다.

**필수 메서드**:
- `parse(sourceCode: string, filePath: string): ParseResult` - 코드 파싱
- `canParse(filePath: string): boolean` - 파싱 가능 여부 확인

**필수 프로퍼티**:
- `supportedExtensions: string[]` - 지원하는 파일 확장자 목록
- `languageName: string` - 언어 이름

**구현체**:
- `TypeScriptParser` - TypeScript/JavaScript 파서
- `PythonParser` - Python 파서

**구현 위치**: `src/parsers/ILanguageParser.ts`

**Source**: docs/terms/language-parser.md:1

---

## [[Parse Result]]

**Type**: entity
**Scope**: global
**Aliases**: 파싱 결과
**Related**: [[Language Parser]], [[Tree-sitter]]

소스 코드 파싱의 결과를 담는 데이터 구조를 의미한다.

**구조**:
```typescript
interface ParseResult {
  imports: ImportInfo[];   // Import 문 목록
  exports: ExportInfo[];   // Export 문 목록
}
```

**포함 정보**:
- **Imports**: 어떤 모듈에서 무엇을 import했는지
- **Exports**: 어떤 interface/class/function을 export했는지

**사용처**:
- Dependency graph 구축
- Export 분석
- Orphan detection

**Source**: docs/terms/parse-result.md:1

---

## [[Parser Factory]]

**Type**: entity
**Scope**: global
**Aliases**: 파서 팩토리
**Related**: [[Language Parser]]

언어별 파서를 관리하고 제공하는 중앙 레지스트리 클래스를 의미한다.

**주요 메서드**:
- `getParser(filePath: string): ILanguageParser | null` - 파일 확장자 기반 파서 반환
- `register(ext: string, parser: ILanguageParser): void` - 새 파서 등록
- `getSupportedExtensions(): string[]` - 지원 확장자 목록
- `reset(): void` - 레지스트리 초기화 (테스트용, `@internal`)

**구현 위치**: `src/parsers/ParserFactory.ts`

**지원 언어**:
- TypeScript/JavaScript (.ts, .tsx, .js, .jsx)
- Python (.py)

**Source**: docs/terms/parser-factory.md:1

---

## [[Tree-sitter]]

**Type**: entity
**Scope**: global
**Aliases**: 트리시터
**Related**: [[Language Parser]], [[Parser Factory]]

점진적(incremental) 파싱을 지원하는 파서 생성 라이브러리를 의미한다.

**특징**:
- 다양한 프로그래밍 언어 지원
- AST (Abstract Syntax Tree) 생성
- 점진적 파싱 (코드 수정 시 일부만 재파싱)
- 에러 복구 (syntax error가 있어도 파싱 계속)

**사용처**:
- TypeScript Parser 구현
- Python Parser 구현
- 소스 코드 분석

**외부 라이브러리**:
- `tree-sitter`
- `tree-sitter-typescript`
- `tree-sitter-python`

**Source**: docs/terms/tree-sitter.md:1

---

## [[User Interface]]

**Type**: entity
**Scope**: global
**Aliases**: UI, 사용자 인터페이스
**Related**: [[CLI]]
**Not to Confuse**: [[Code Interface]]

사용자와 소프트웨어가 상호작용하는 시각적/텍스트 인터페이스를 의미한다.

**타입**:
- CLI (Command Line Interface) - 텍스트 기반
- GUI (Graphical User Interface) - 그래픽 기반
- Web UI - 웹 브라우저 기반

**vs [[Code Interface]]**:
- User Interface: 사용자와의 상호작용 화면
- Code Interface: 코드 수준의 TypeScript interface

---

**Document Status**: ✅ Complete
**Total Terms**: 28
**Last Updated**: 2025-10-24

**Source**: docs/terms/user-interface.md:1

---

<!-- Type: Process (5 terms) -->

## [[File-level Validation]]

**Type**: process
**Scope**: global
**Aliases**: 파일 수준 검증
**Related**: [[Interface-level Validation]], [[Validation]], [[Orphan Detection]]

파일 단위로 문서화 여부를 검증하는 프로세스를 의미한다 (현재 시스템).

**검증 방법**:
1. 파일이 문서의 `code_references`에 포함되었는지 확인
2. 포함되었다면, 해당 파일의 **모든** export가 문서화된 것으로 간주

**한계**:
- 파일이 문서화되면 내부 모든 export가 문서화된 것으로 간주
- 일부 export만 실제로 사용/문서화된 경우 감지 불가
- Interface 단위 추적 불가능

**Source**: docs/terms/file-level-validation.md:1

---

## [[Interface-level Validation]]

**Type**: process
**Scope**: global
**Aliases**: 인터페이스 수준 검증
**Related**: [[File-level Validation]], [[Validation]], [[Orphan Detection]]

개별 코드 인터페이스 단위로 문서화 여부를 검증하는 프로세스를 의미한다.

**검증 대상**:
- [[Entry Point Module]]의 모든 [[Top-Level Interface]]
- 각 interface가 문서에 명시되었는지 확인
- Method-level 추적 (선택적)

**검증 방법**:
1. [[Entry Point Module]]에서 모든 exported interface 추출
2. [[Interface Graph]]를 사용하여 interface 사용 관계 구축
3. 각 public interface가 문서화되었는지 확인
4. Orphan interface (exported but undocumented) 보고

**File-level과의 차이**:
- 더 세밀한 단위 (file → interface)
- False positive 감소 (파일 내 일부만 문서화된 경우 감지)
- Method 수준 추적 가능

**Source**: docs/terms/interface-level-validation.md:1

---

## [[Orphan Detection]]

**Type**: process
**Scope**: global
**Aliases**: 고아 탐지
**Related**: [[Spec Orphan]]

문서화되지 않았고 사용되지도 않는 코드나 파일을 탐지하는 프로세스를 의미한다.

**탐지 대상**:
- 문서에 참조되지 않은 파일
- 다른 코드에서 import되지 않은 파일
- Export되었지만 사용되지 않는 interface

**검증 방법**:
1. 문서에서 참조된 파일 수집
2. Import 의존성 그래프 구축
3. 문서화되지도 않고 사용되지도 않는 파일 식별

**관련 명령어**:
```bash
edgedoc validate orphans
```

**Source**: docs/terms/orphan-detection.md:1

---

## [[Synchronization]]

**Type**: process
**Scope**: global
**Aliases**: 동기화, sync
**Related**: [[Code References]]

문서의 `code_references` 필드를 코드의 실제 의존성과 동기화하는 프로세스를 의미한다.

**동작 방식**:
1. 문서의 `entry_point` 또는 `code_references` 읽기
2. 해당 파일들의 import 의존성 분석
3. Transitive dependencies 추적
4. 문서의 `code_references` 필드 업데이트

**모드** (향후 계획):
- `file`: 파일 수준 동기화 (현재)
- `interface`: Interface 수준 동기화
- `hybrid`: 두 가지 모두

**관련 명령어**:
```bash
edgedoc sync                   # 동기화 실행
edgedoc sync --dry-run         # 시뮬레이션만
```

**Source**: docs/terms/synchronization.md:1

---

## [[Validation]]

**Type**: process
**Scope**: global
**Aliases**: 검증
**Related**: [[Interface-level Validation]], [[File-level Validation]]

문서와 코드의 일관성을 확인하는 프로세스를 의미한다.

**검증 항목**:
1. **Migration**: tasks → tasks-v2 마이그레이션 상태
2. **Naming**: 네이밍 컨벤션 준수 (interface, shared type)
3. **Structure**: 문서 구조 (순환 의존성, frontmatter)
4. **Orphans**: 고아 파일 (문서화/사용 안 됨)
5. **Spec Orphans**: 스펙 고아 (export되었지만 미문서화)
6. **Terms**: 용어 일관성 (정의/참조)

**관련 명령어**:
```bash
edgedoc validate all           # 전체 검증
edgedoc validate naming        # 네이밍만
edgedoc validate orphans       # 고아 파일만
edgedoc validate terms         # 용어만
```

**Source**: docs/terms/validation.md:1

---

<!-- Type: Attribute (1 terms) -->

## [[Code References]]

**Type**: attribute
**Scope**: global
**Aliases**: 코드 참조
**Related**: [[Synchronization]]

문서 frontmatter에서 해당 문서가 참조하는 소스 코드 파일 목록을 의미한다.

**형식**:
```yaml
---
code_references:
  - "src/parsers/ParserFactory.ts"
  - "src/parsers/ILanguageParser.ts"
  - "src/types/parser.ts"
---
```

**용도**:
- [[Orphan Detection]]에서 문서화된 파일 식별
- [[Synchronization]]의 동기화 대상
- 문서-코드 연결 추적

**유지 방법**:
- 수동 작성
- `edgedoc sync` 명령으로 자동 업데이트

**Source**: docs/terms/code-references.md:1

---

<!-- Type: Abbreviation (2 terms) -->

## [[CLI]]

**Type**: abbreviation
**Scope**: global
**Aliases**: 커맨드라인 인터페이스, 명령줄 인터페이스
**Related**: [[MCP]], [[Entry Point Module]]

터미널 또는 명령 프롬프트에서 텍스트 명령으로 실행되는 사용자 인터페이스를 의미한다.

**이 프로젝트의 CLI**:
```bash
edgedoc init                    # 프로젝트 초기화
edgedoc validate all            # 전체 검증
edgedoc sync                    # 동기화
edgedoc analyze entry-points    # 진입점 분석
```

**구현 위치**: `src/cli.ts`

**Source**: docs/terms/cli.md:1

---

## [[MCP]]

**Type**: abbreviation
**Scope**: global
**Aliases**: 모델 컨텍스트 프로토콜
**Related**: [[CLI]], [[Tree-sitter]]

LLM(Large Language Model)이 외부 도구 및 데이터 소스와 상호작용하기 위한 표준 프로토콜을 의미한다.

**구성 요소**:
- **Tools**: LLM이 호출할 수 있는 함수
- **Resources**: LLM이 접근할 수 있는 데이터
- **Prompts**: 재사용 가능한 프롬프트 템플릿

**이 프로젝트에서의 사용**:
- `src/index.ts`: MCP 서버 구현
- edgedoc을 MCP 도구로 노출

**Source**: docs/terms/mcp.md:1

---

<!-- Type: Other (1 terms) -->

## [[Term Name]]

**Scope**: global
**Aliases**: 동의어, 다국어 표현

명확한 정의문...
```

**구성 요소**:
- **Term**: 용어명 (canonical name)
- **Definition**: 정의문 (what it means)
- **Aliases**: 동의어, 다국어 표현
- **Type**: 용어 타입 (concept, entity, process 등)
- **Scope**: 적용 범위 (global, document)
- **Related**: 관련 용어

**vs [[Type Definition]]**:
- Term Definition: 문서의 용어 정의
- Type Definition: 코드의 타입 정의

**Source**: docs/terms/term-name.md:1

---

**Document Status**: ✅ Auto-generated
**Total Terms**: 31
**Last Updated**: 2025-10-26
