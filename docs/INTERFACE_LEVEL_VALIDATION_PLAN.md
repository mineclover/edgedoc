# Interface-Level Validation Implementation Plan

## Î™©Ìëú

**ÌååÏùº Îã®ÏúÑ ‚Üí Ïù∏ÌÑ∞ÌéòÏù¥Ïä§(ÏµúÏÉÅÏúÑ export) Îã®ÏúÑ Í≥†ÎèÑÌôî**

ÌòÑÏû¨ ÏãúÏä§ÌÖúÏùÄ ÌååÏùºÏù¥ Î¨∏ÏÑúÌôîÎêòÎ©¥ ÎÇ¥Î∂ÄÏùò Î™®Îì† exportÍ∞Ä Î¨∏ÏÑúÌôîÎêú Í≤ÉÏúºÎ°ú Í∞ÑÏ£ºÌï©ÎãàÎã§. Ïù¥Î•º Í∞úÏÑ†ÌïòÏó¨ **ÏµúÏÉÅÏúÑ public interface(export)Î•º Í∞úÎ≥ÑÏ†ÅÏúºÎ°ú Ï∂îÏ†Å**ÌïòÍ≥† Í≤ÄÏ¶ùÌï©ÎãàÎã§.

## ÌïµÏã¨ Í∞úÎÖê

### 1. Entry Point Module (ÏßÑÏûÖÏ†ê Î™®Îìà)

**Ï†ïÏùò**: ÌîÑÎ°úÏ†ùÌä∏ÏóêÏÑú Ïô∏Î∂ÄÎ°ú ÎÖ∏Ï∂úÎêòÎäî ÏµúÏÉÅÏúÑ public APIÎ•º Ï†úÍ≥µÌïòÎäî Î™®Îìà

**ÌäπÏßï**:
- ÏÇ¨Ïö©ÏûêÍ∞Ä ÏßÅÏ†ë importÌïòÎäî Î™®Îìà
- ÎÇ¥Î∂Ä Íµ¨ÌòÑ ÏÑ∏Î∂ÄÏÇ¨Ìï≠Ïù¥ ÏïÑÎãå Í≥µÍ∞ú API
- ÌîÑÎ°úÏ†ùÌä∏Ïùò "ÏñºÍµ¥"Ïù¥ ÎêòÎäî Ïù∏ÌÑ∞ÌéòÏù¥Ïä§

**ÏòàÏãú**:

```typescript
// ‚úÖ Entry Point Module
src/parsers/ParserFactory.ts
  - export class ParserFactory  // ÏµúÏÉÅÏúÑ public interface

// ‚ùå Not Entry Point (Internal)
src/parsers/TypeScriptParser.ts
  - export class TypeScriptParser  // ParserFactory ÎÇ¥Î∂ÄÏóêÏÑúÎßå ÏÇ¨Ïö©
```

**ÌòÑÏû¨ ÌîÑÎ°úÏ†ùÌä∏Ïùò Entry Point Modules**:
1. `src/cli.ts` - CLI ÏßÑÏûÖÏ†ê
2. `src/index.ts` - MCP ÏÑúÎ≤Ñ ÏßÑÏûÖÏ†ê
3. `src/parsers/ParserFactory.ts` - ÌååÏÑú ÏãúÏä§ÌÖú Í≥µÍ∞ú API
4. `src/shared/i18n.ts` - i18n ÏãúÏä§ÌÖú Í≥µÍ∞ú API
5. `src/utils/config.ts` - ÏÑ§Ï†ï ÏãúÏä§ÌÖú Í≥µÍ∞ú API

### 2. Top-Level Interface (ÏµúÏÉÅÏúÑ Ïù∏ÌÑ∞ÌéòÏù¥Ïä§)

**Ï†ïÏùò**: ÌååÏùºÏóêÏÑú exportÎêú ÏµúÏÉÅÏúÑ Ïã¨Î≥º (class, interface, type, function, const)

**Î∂ÑÎ•ò**:

```typescript
// Public API (Î¨∏ÏÑúÌôî ÌïÑÏöî)
export class ParserFactory { ... }      // ‚úÖ ÏµúÏÉÅÏúÑ
export function t(): Messages { ... }   // ‚úÖ ÏµúÏÉÅÏúÑ
export interface ILanguageParser { ... } // ‚úÖ ÏµúÏÉÅÏúÑ

// Internal Implementation (Î¨∏ÏÑúÌôî ÏÑ†ÌÉù)
class InternalHelper { ... }            // ‚ùå ÎπÑÍ≥µÍ∞ú
function privateUtil() { ... }          // ‚ùå ÎπÑÍ≥µÍ∞ú
```

## ÌòÑÏû¨ ÏãúÏä§ÌÖú Î∂ÑÏÑù

### Í≤ÄÏ¶ù ÌùêÎ¶Ñ

```
üìÑ File Level (ÌòÑÏû¨)
  ‚îú‚îÄ orphans.ts: ÌååÏùºÏù¥ Î¨∏ÏÑúÌôîÎêòÏóàÎäîÍ∞Ä?
  ‚îÇ   ‚îî‚îÄ YES ‚Üí ÌååÏùº ÎÇ¥ Î™®Îì† exportÍ∞Ä Î¨∏ÏÑúÌôîÎê®
  ‚îî‚îÄ spec-orphans.ts: export Ï∂îÏ∂úÎßå Ìï® (ÌååÏùº Îã®ÏúÑ ÌåêÎã®)

üéØ Interface Level (Î™©Ìëú)
  ‚îú‚îÄ orphans.ts: ÌååÏùº + ÏµúÏÉÅÏúÑ export Ï∂îÏ†Å
  ‚îÇ   ‚îî‚îÄ Entry Point ModuleÏùò public interface Í≤ÄÏ¶ù
  ‚îî‚îÄ spec-orphans.ts: Í∞úÎ≥Ñ export ÏÇ¨Ïö© Ïó¨Î∂Ä Ï∂îÏ†Å
      ‚îî‚îÄ Import Í∑∏ÎûòÌîÑÏóêÏÑú Ïã§Ï†ú ÏÇ¨Ïö©ÎêòÎäî export ÌôïÏù∏
```

### Î¨∏Ï†úÏ†ê

1. **Í≥ºÎèÑÌïú Î¨∏ÏÑúÌôî**: ÎÇ¥Î∂Ä Íµ¨ÌòÑÎèÑ Î¨∏ÏÑúÌôîÎêú Í≤ÉÏúºÎ°ú Í∞ÑÏ£º
2. **ÏÇ¨Ïö©ÎêòÏßÄ ÏïäÎäî export ÌÉêÏßÄ Î∂àÍ∞Ä**: ÌååÏùºÎßå Î¨∏ÏÑúÌôîÎêòÎ©¥ OK
3. **Public API Î∂àÎ™ÖÌôï**: Ïñ¥Îñ§ Í≤ÉÏù¥ Í≥µÍ∞ú APIÏù∏ÏßÄ Íµ¨Î∂Ñ Ïñ¥Î†§ÏõÄ

### ÏòàÏãú: ParserFactory

**ÌòÑÏû¨**:
```yaml
# tasks/features/09_MultiLanguageParser.md
entry_point: "src/parsers/ParserFactory.ts"
code_references:
  - "src/parsers/ParserFactory.ts"
  - "src/parsers/TypeScriptParser.ts"  # ÎÇ¥Î∂Ä Íµ¨ÌòÑÎèÑ Î™ÖÏãú
  - "src/parsers/PythonParser.ts"      # ÎÇ¥Î∂Ä Íµ¨ÌòÑÎèÑ Î™ÖÏãú
```

**Î™©Ìëú**:
```yaml
# tasks/features/09_MultiLanguageParser.md
entry_point: "src/parsers/ParserFactory.ts"
public_interfaces:
  - "src/parsers/ParserFactory.ts::ParserFactory"
  - "src/parsers/ILanguageParser.ts::ILanguageParser"
code_references:
  - "src/parsers/ParserFactory.ts"
  - "src/parsers/ILanguageParser.ts"
  # TypeScriptParser, PythonParserÎäî ÎÇ¥Î∂Ä Íµ¨ÌòÑ (ÏûêÎèô Ï∂îÏ†Å)
```

## Íµ¨ÌòÑ Í≥ÑÌöç

### Phase 1: Entry Point Ï†ïÏùò

#### 1.1 Frontmatter ÌôïÏû•

```yaml
---
entry_point: "src/parsers/ParserFactory.ts"
entry_point_type: "module"  # NEW: module | class | function
public_interfaces:           # NEW: ÏµúÏÉÅÏúÑ public API Î™©Î°ù
  - name: "ParserFactory"
    type: "class"
    methods:
      - "getParser"
      - "getSupportedExtensions"
      - "register"
  - name: "ILanguageParser"
    file: "src/parsers/ILanguageParser.ts"
    type: "interface"
code_references:
  - "src/parsers/ParserFactory.ts"
  - "src/parsers/ILanguageParser.ts"
---
```

#### 1.2 Entry Point ÏûêÎèô Í∞êÏßÄ

**Í∑úÏπô**:
1. CLI ÏßÑÏûÖÏ†ê: `src/cli.ts`, `src/index.ts`
2. Îã§Î•∏ featureÏóêÏÑú ÏßÅÏ†ë importÌïòÎäî ÌååÏùº
3. `entry_point` frontmatterÏóê Î™ÖÏãúÎêú ÌååÏùº

### Phase 2: Interface-Level Ï∂îÏ∂ú

#### 2.1 Export Î∂ÑÏÑù Í∞ïÌôî

```typescript
// src/parsers/ExportAnalyzer.ts (NEW)

interface TopLevelExport {
  name: string;
  type: 'class' | 'interface' | 'type' | 'function' | 'const';
  file: string;
  isPublic: boolean;  // export ÌÇ§ÏõåÎìú Ï°¥Ïû¨ Ïó¨Î∂Ä
  methods?: string[]; // classÏù∏ Í≤ΩÏö∞ public Î©îÏÑúÎìú Î™©Î°ù
  location: { line: number; column: number };
}

export class ExportAnalyzer {
  /**
   * Extract top-level public interfaces from a file
   */
  static extractPublicInterfaces(filePath: string): TopLevelExport[] {
    const parser = ParserFactory.getParser(filePath);
    if (!parser) return [];

    const content = readFileSync(filePath, 'utf-8');
    const { exports } = parser.parse(content, filePath);

    // Filter: Only top-level exports
    return exports.filter(exp => {
      // Exclude default exports of internal helpers
      // Exclude re-exports
      return exp.isPublic && !exp.isReExport;
    });
  }

  /**
   * Extract public methods from a class
   */
  static extractPublicMethods(
    filePath: string,
    className: string
  ): string[] {
    // Use tree-sitter to find class definition
    // Extract public methods (not private/protected)
    return [];
  }
}
```

#### 2.2 Import Í∑∏ÎûòÌîÑ ÌôïÏû•

```typescript
// src/tools/interface-graph.ts (NEW)

interface InterfaceUsage {
  interface: string;  // "ParserFactory.getParser"
  usedBy: string[];   // ["src/tools/sync.ts", "src/tools/orphans.ts"]
  importType: 'direct' | 'indirect';
}

export class InterfaceGraph {
  /**
   * Build interface-level usage graph
   */
  static buildInterfaceGraph(
    codeReferences: Map<string, CodeReference>
  ): Map<string, InterfaceUsage> {
    const graph = new Map<string, InterfaceUsage>();

    for (const [file] of codeReferences) {
      const imports = this.extractImports(file);

      for (const imp of imports) {
        // Track which specific exports are imported
        // e.g., import { ParserFactory } from './ParserFactory'
        for (const name of imp.names) {
          const key = `${imp.source}::${name}`;
          if (!graph.has(key)) {
            graph.set(key, {
              interface: key,
              usedBy: [],
              importType: 'direct',
            });
          }
          graph.get(key)!.usedBy.push(file);
        }
      }
    }

    return graph;
  }

  /**
   * Check if an interface is used
   */
  static isInterfaceUsed(
    file: string,
    interfaceName: string,
    graph: Map<string, InterfaceUsage>
  ): boolean {
    const key = `${file}::${interfaceName}`;
    const usage = graph.get(key);
    return usage ? usage.usedBy.length > 0 : false;
  }
}
```

### Phase 3: Interface-Level Í≤ÄÏ¶ù

#### 3.1 Orphan Í≤ÄÏ¶ù Í∞ïÌôî

```typescript
// src/tools/spec-orphans.ts (ENHANCED)

export interface InterfaceOrphan {
  file: string;
  interfaceName: string;
  interfaceType: 'class' | 'interface' | 'type' | 'function' | 'const';
  reason: 'not_documented' | 'not_used' | 'not_public';
  methods?: string[];  // classÏù∏ Í≤ΩÏö∞ ÏÇ¨Ïö©ÎêòÏßÄ ÏïäÎäî Î©îÏÑúÎìú
}

export async function validateInterfaceOrphans(
  options: ValidationOptions = {}
): Promise<InterfaceOrphanResult> {
  const projectPath = options.projectPath || process.cwd();

  // 1. Extract entry point modules
  const entryPoints = extractEntryPoints(projectPath);

  // 2. Extract public interfaces from entry points
  const publicInterfaces = new Map<string, TopLevelExport[]>();
  for (const ep of entryPoints) {
    const interfaces = ExportAnalyzer.extractPublicInterfaces(ep);
    publicInterfaces.set(ep, interfaces);
  }

  // 3. Build interface-level usage graph
  const usageGraph = InterfaceGraph.buildInterfaceGraph(codeReferences);

  // 4. Check each interface
  const orphans: InterfaceOrphan[] = [];

  for (const [file, interfaces] of publicInterfaces) {
    for (const iface of interfaces) {
      const isDocumented = checkInterfaceDocumented(file, iface.name, docs);
      const isUsed = InterfaceGraph.isInterfaceUsed(file, iface.name, usageGraph);

      if (!isDocumented) {
        orphans.push({
          file,
          interfaceName: iface.name,
          interfaceType: iface.type,
          reason: 'not_documented',
        });
      } else if (!isUsed && !isEntryPoint(file, iface.name)) {
        // Entry pointÎäî ÏÇ¨Ïö©ÎêòÏßÄ ÏïäÏïÑÎèÑ OK (Ïô∏Î∂Ä ÏÇ¨Ïö©ÏûêÏö©)
        orphans.push({
          file,
          interfaceName: iface.name,
          interfaceType: iface.type,
          reason: 'not_used',
        });
      }

      // ClassÏù∏ Í≤ΩÏö∞ Î©îÏÑúÎìúÎ≥Ñ Í≤ÄÏ¶ù
      if (iface.type === 'class' && iface.methods) {
        const unusedMethods = checkUnusedMethods(
          file,
          iface.name,
          iface.methods,
          usageGraph
        );
        if (unusedMethods.length > 0) {
          orphans.push({
            file,
            interfaceName: iface.name,
            interfaceType: 'class',
            reason: 'not_used',
            methods: unusedMethods,
          });
        }
      }
    }
  }

  return {
    success: orphans.length === 0,
    totalInterfaces: countTotalInterfaces(publicInterfaces),
    documentedInterfaces: countDocumented(publicInterfaces, docs),
    orphans,
  };
}
```

#### 3.2 Î¨∏ÏÑú Í≤ÄÏ¶ù

```typescript
// src/tools/validate-interface-docs.ts (NEW)

export function checkInterfaceDocumented(
  file: string,
  interfaceName: string,
  docs: Map<string, DocumentInfo>
): boolean {
  for (const [docPath, docInfo] of docs) {
    // Check if public_interfaces mentions this interface
    if (docInfo.publicInterfaces) {
      const found = docInfo.publicInterfaces.find(
        (pi) => pi.file === file && pi.name === interfaceName
      );
      if (found) return true;
    }

    // Fallback: Check if file is in code_references
    if (docInfo.codeReferences.includes(file)) {
      // Assume all exports from documented files are documented
      // (backward compatibility)
      return true;
    }
  }

  return false;
}
```

### Phase 4: ÏßÑÏûÖÏ†ê Î™®Îìà ÏûêÎèô Í∞êÏßÄ

#### 4.1 Entry Point Detection

```typescript
// src/tools/entry-point-detector.ts (NEW)

export interface EntryPointModule {
  file: string;
  type: 'cli' | 'api' | 'library';
  publicInterfaces: string[];
  reason: string;  // Why this is considered an entry point
}

export class EntryPointDetector {
  /**
   * Detect entry point modules
   */
  static detect(projectPath: string): EntryPointModule[] {
    const entryPoints: EntryPointModule[] = [];

    // 1. CLI entry points
    const cliFiles = ['src/cli.ts', 'src/index.ts'];
    for (const file of cliFiles) {
      if (fileExists(join(projectPath, file))) {
        entryPoints.push({
          file,
          type: 'cli',
          publicInterfaces: this.extractExports(file),
          reason: 'CLI entry point',
        });
      }
    }

    // 2. Package.json exports
    const pkgPath = join(projectPath, 'package.json');
    if (fileExists(pkgPath)) {
      const pkg = JSON.parse(readFileSync(pkgPath, 'utf-8'));

      // Check "main", "exports", "types"
      if (pkg.main) {
        const mainFile = pkg.main.replace(/^\.\//, '');
        entryPoints.push({
          file: mainFile,
          type: 'library',
          publicInterfaces: this.extractExports(mainFile),
          reason: 'package.json main field',
        });
      }
    }

    // 3. Explicitly marked in docs
    const docs = parseDocuments(projectPath);
    for (const doc of docs) {
      if (doc.entryPoint && doc.entryPointType === 'module') {
        entryPoints.push({
          file: doc.entryPoint,
          type: 'api',
          publicInterfaces: this.extractExports(doc.entryPoint),
          reason: 'Marked in documentation',
        });
      }
    }

    // 4. Frequently imported modules (heuristic)
    const importGraph = buildImportGraph(projectPath);
    const importCounts = this.countImports(importGraph);

    for (const [file, count] of importCounts) {
      if (count >= 3) {  // Imported by 3+ different files
        entryPoints.push({
          file,
          type: 'library',
          publicInterfaces: this.extractExports(file),
          reason: `Imported by ${count} files`,
        });
      }
    }

    return this.deduplicate(entryPoints);
  }

  private static extractExports(file: string): string[] {
    const parser = ParserFactory.getParser(file);
    if (!parser) return [];

    const content = readFileSync(file, 'utf-8');
    const { exports } = parser.parse(content, file);
    return exports.map(e => e.name);
  }

  private static countImports(
    graph: Map<string, Set<string>>
  ): Map<string, number> {
    const counts = new Map<string, number>();

    for (const imports of graph.values()) {
      for (const imported of imports) {
        counts.set(imported, (counts.get(imported) || 0) + 1);
      }
    }

    return counts;
  }

  private static deduplicate(
    entryPoints: EntryPointModule[]
  ): EntryPointModule[] {
    const seen = new Map<string, EntryPointModule>();

    for (const ep of entryPoints) {
      if (!seen.has(ep.file)) {
        seen.set(ep.file, ep);
      } else {
        // Merge reasons
        const existing = seen.get(ep.file)!;
        existing.reason += `, ${ep.reason}`;
      }
    }

    return Array.from(seen.values());
  }
}
```

## ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò Í≥ÑÌöç

### Step 1: Í∏∞Ï°¥ ÏãúÏä§ÌÖú Ïú†ÏßÄ (Backward Compatible)

```typescript
// config.ts
export interface ValidationConfig {
  mode: 'file' | 'interface';  // Default: 'file'
  entryPointDetection: 'auto' | 'manual';  // Default: 'manual'
}
```

### Step 2: Ï†êÏßÑÏ†Å Ï†ÑÌôò

1. **Phase 1**: `public_interfaces` ÌïÑÎìú Ï∂îÍ∞Ä (ÏÑ†ÌÉùÏÇ¨Ìï≠)
2. **Phase 2**: Entry point ÏûêÎèô Í∞êÏßÄ ÎèÑÍµ¨ Ï†úÍ≥µ
3. **Phase 3**: Interface-level Í≤ÄÏ¶ù ÌôúÏÑ±Ìôî (opt-in)
4. **Phase 4**: Í∏∞Î≥∏Í∞íÏùÑ interface-levelÎ°ú Î≥ÄÍ≤Ω

### Step 3: Î¨∏ÏÑú ÏóÖÎç∞Ïù¥Ìä∏

```bash
# 1. Entry point ÏûêÎèô Í∞êÏßÄ
edgedoc detect-entry-points

# Ï∂úÎ†•:
# üìç Detected Entry Points:
#   1. src/cli.ts (CLI entry point)
#   2. src/parsers/ParserFactory.ts (Imported by 5 files)
#   3. src/shared/i18n.ts (Imported by 8 files)

# 2. Public interfaces Ï∂îÏ∂ú
edgedoc extract-interfaces --entry-point src/parsers/ParserFactory.ts

# Ï∂úÎ†•:
# üéØ Public Interfaces in src/parsers/ParserFactory.ts:
#   - class ParserFactory
#     - getParser(filePath: string)
#     - getSupportedExtensions()
#     - register(parser: ILanguageParser)

# 3. Interface-level validation
edgedoc validate spec-orphans --mode interface

# Ï∂úÎ†•:
# ‚ùå Orphan Interfaces:
#   src/parsers/TypeScriptParser.ts::extractStringValue
#     Reason: not_used (private method, never called)
```

## ÏòàÏÉÅ Ìö®Í≥º

### Before (File-Level)
```
‚úÖ 23 files documented
‚úÖ 0 orphan files
‚úÖ 48 exports (all considered documented)
```

### After (Interface-Level)
```
‚úÖ 23 files documented
‚úÖ 5 entry point modules
‚úÖ 12 public interfaces
‚ö†Ô∏è  3 unused interfaces:
   - TypeScriptParser::extractStringValue (private utility)
   - PythonParser::extractClassName (internal helper)
   - i18n::KO_MESSAGES (internal constant)
‚úÖ 45 exports documented or used
```

## Íµ¨ÌòÑ ÏàúÏÑú

1. ‚úÖ **Phase 1**: ÌòÑÏû¨ ÏãúÏä§ÌÖú Î∂ÑÏÑù (ÏôÑÎ£å)
2. üîÑ **Phase 2**: Entry Point Detector Íµ¨ÌòÑ
3. üîÑ **Phase 3**: ExportAnalyzer Íµ¨ÌòÑ (public interface Ï∂îÏ∂ú)
4. üîÑ **Phase 4**: InterfaceGraph Íµ¨ÌòÑ (ÏÇ¨Ïö© Ïó¨Î∂Ä Ï∂îÏ†Å)
5. üîÑ **Phase 5**: Interface-level validation Íµ¨ÌòÑ
6. üîÑ **Phase 6**: CLI Î™ÖÎ†πÏñ¥ Ï∂îÍ∞Ä
7. üîÑ **Phase 7**: Î¨∏ÏÑú ÏóÖÎç∞Ïù¥Ìä∏ Î∞è ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò

## Ï∞∏Í≥† ÏûêÎ£å

### ÌòÑÏû¨ ÏΩîÎìúÎ≤†Ïù¥Ïä§
- `src/tools/spec-orphans.ts` - ÌååÏùº Îã®ÏúÑ Í≤ÄÏ¶ù (Í∞úÏÑ† ÎåÄÏÉÅ)
- `src/parsers/ILanguageParser.ts` - Export Ï∂îÏ∂ú Ïù∏ÌÑ∞ÌéòÏù¥Ïä§
- `src/parsers/ParserFactory.ts` - Entry point ÏòàÏãú

### Í¥ÄÎ†® Î¨∏ÏÑú
- `docs/VALIDATION.md` - ÌòÑÏû¨ Í≤ÄÏ¶ù ÏãúÏä§ÌÖú
- `tasks/features/09_MultiLanguageParser.md` - Entry point ÏÇ¨Ïö© ÏòàÏãú

## Q&A

**Q: Î™®Îì† exportÎ•º Î¨∏ÏÑúÌôîÌï¥Ïïº ÌïòÎÇòÏöî?**
A: Entry point moduleÏùò public interfaceÎßå Î¨∏ÏÑúÌôîÌïòÎ©¥ Îê©ÎãàÎã§. ÎÇ¥Î∂Ä Íµ¨ÌòÑÏùÄ ÏûêÎèôÏúºÎ°ú Ï∂îÏ†ÅÎê©ÎãàÎã§.

**Q: Private methodÎèÑ Í≤ÄÏ¶ùÌïòÎÇòÏöî?**
A: Í∏∞Î≥∏Ï†ÅÏúºÎ°ú public exportÎßå Í≤ÄÏ¶ùÌï©ÎãàÎã§. ConfigÎ°ú private method Í≤ÄÏ¶ùÎèÑ ÌôúÏÑ±Ìôî Í∞ÄÎä•Ìï©ÎãàÎã§.

**Q: Í∏∞Ï°¥ Î¨∏ÏÑúÎäî Ïñ¥ÎñªÍ≤å ÎêòÎÇòÏöî?**
A: Í∏∞Ï°¥ `code_references`Îäî Í∑∏ÎåÄÎ°ú ÎèôÏûëÌï©ÎãàÎã§. `public_interfaces`Îäî ÏÑ†ÌÉùÏÇ¨Ìï≠ÏûÖÎãàÎã§.

**Q: Entry pointÎäî Ïñ¥ÎñªÍ≤å Í≤∞Ï†ïÌïòÎÇòÏöî?**
A: CLI ÏßÑÏûÖÏ†ê, package.json, Î¨∏ÏÑúÏùò entry_point ÌïÑÎìú, Í∑∏Î¶¨Í≥† 3Í∞ú Ïù¥ÏÉÅÏùò ÌååÏùºÏóêÏÑú importÎêòÎäî Î™®ÎìàÏù¥ ÏûêÎèôÏúºÎ°ú entry pointÎ°ú Í∞ÑÏ£ºÎê©ÎãàÎã§.
